在 ```Part.2.D.4-recursion``` 这一节里面，关于递归函数内的变量和递归函数外的变量不是同一个变量的推导过程，可能存在一处错误，结论是正确的，但是证明过程是错误的，具体说明如下：

### 以下是原文中的一段代码：
```
# 观察一下名称相同的一个全局变量和局部变量的不同内存地址
def f(n):
    return id(n)

n = 5
print(id(n))    # 全局变量 n 的内存地址
print(id(f(n))) # 局部变量 n 的内存地址。
```

### 以上代码运行结果如下：
```
140717025113040
2073715336592
```

以上证明的错误在于，```id(n)``` 返回的是变量 ```n``` 的内存地址，但是```id(f(n))```返回的是 ```id(n)``` 的内存地址，换句话说 ```id(f(n))``` 返回的是变量 ```n``` 的地址的地址
，所以 ```print(id(n))``` 和 ```print(id(f(n)))``` 返回的值不一样，并不是因为 ```n``` 在函数内还是在函数外，而是因为他们本来就不是一个东西，
我把原来的代码修改了一下，正确的证明方法应该如下：

```
# 观察一下名称相同的一个全局变量和局部变量的不同内存地址
def f(n):
    print(id(n))
    n = n + 1
    return n

n = 5
print(id(n))    # 全局变量 n 的内存地址
print(id(f(n))) # 局部变量 n 的内存地址。
```

### 以上代码运行结果如下：
```
140717025113040
140717025113040
140717025113072
```
  
 从以上结果可以看出，前两个地址是一样的，这说明在函数内对 ```n``` 进行赋值之前，在函数外输出 ```id(n)``` 和在函数内输出 ```id(n)``` 结果是一样的，这说明这两个 ```n``` 是同一个 ```n``` ， 只有在函数内对 ```n``` 进行赋值操作后， 此时的 ```n``` 才会变成另一个 ```n``` ，意思就是，在对 ```n``` 赋值时，程序又创建了一个新的局部变量 ```n``` 来代替外部的 ```n ``` 。
 
 以上就是我对 ```python``` 中全局变量和局部变量的理解，希望笑来老师能看到这篇文章。
 
